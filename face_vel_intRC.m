function [u_face,v_face] = face_vel_intRC(nx,ny,nx_upstr,nx_dwnstr,...
    u_face,v_face,u,v,aP,aPv,alpha_uv,p,dxVec,dyVec,p0)

%Rie chow interpolation for face velocities
%   uf= 0.5*(uP + uA) + df*(Pp-Pa) - 0.5((VP/aP)*grad(p)p + 
%  (VA/aA)*grad(p)A)

% u face velocity

    %West side
    j=2;
    for i =1:ny
        u_face(i,j)=0.5*(u(i,j-1) + u(i,j))+ ...
            alpha_uv*(0.5*dyVec(i)*(1/aP(i,j-1) + ... 
            1/aP(i,j))*(p(i,j-1)-p(i,j)) - ...
            0.5*dyVec(i)*(1/aP(i,j-1))*(p(i,j)-p(i,j-1)) -...
            0.25*dyVec(i)*(1/aP(i,j))*(p(i,j+1)-p(i,j-1)));
    end 
    
    %Interior cells 
    for i=1:ny
        for j=3:nx-1
            u_face(i,j)=0.5*(u(i,j-1) + u(i,j)) + ...
                alpha_uv*(0.5*dyVec(i)*(1/aP(i,j-1) + ... 
                1/aP(i,j))*(p(i,j-1)-p(i,j)) - ... 
                0.25*dyVec(i)*(1/aP(i,j-1))*(p(i,j)-p(i,j-2)) - ... 
                0.25*dyVec(i)*(1/aP(i,j))*(p(i,j+1)-p(i,j-1))); 
        end
    end
    
    %East side
    j=nx;
    for i =1:ny
        u_face(i,j)=0.5*(u(i,j-1) + u(i,j)) + ...
            alpha_uv*(0.5*dyVec(i)*(1/aP(i,j-1) + 1/aP(i,j))*...
            (p(i,j-1)-p(i,j)) - 0.25*dyVec(i)*(1/aP(i,j-1))*(p(i,j)-p(i,j-2)) ...
            -0.25*dyVec(i)*(1/aP(i,j))*(p0 -0.5*(p(i,j-1) + p(i,j))));
    end
    
    % v face velocity
    
    %North side 
    i=2;
    for j=1:nx
        v_face(i,j)=0.5*(v(i-1,j) +v(i,j)) + ...
            alpha_uv*(0.5*dxVec(j)*(1/aP(i-1,j) + ...
            1/aP(i,j))*(p(i-1,j)-p(i,j)) - ...
            0.5*dxVec(j)*(1/aP(i-1,j))*(0.5*(p(i,j) - p(i+1,j))) - ...
            0.25*dxVec(j)*(1/aP(i,j))*(p(i+1,j) -p(i-1,j)));
    end
    
    %Interior Cells 
    
    for i=3:ny-2
        for j=1:nx
            v_face(i,j)=0.5*(v(i-1,j) +v(i,j)) + ... 
                alpha_uv*(0.5*dxVec(j)*(1/aP(i-1,j) + ...
                1/aP(i,j))*(p(i-1,j)-p(i,j)) - ... 
                0.25*dxVec(j)*(1/aP(i-1,j))*(p(i,j)- p(i-2,j)) - ...
                0.25*dxVec(j)*(1/aP(i,j))*(p(i+1,j) -p(i-1,j)));
        end
    end
    
    %South side (Use aPv for symetric boundary condition)
    
    i=ny-1;
    for j=1:nx
        if (j<=nx_upstr) || j>(nx-nx_dwnstr)
            %use aPv coeffitients
            v_face(i,j)=0.5*(v(i-1,j) +v(i,j)) + ...
                alpha_uv*(0.5*dxVec(j)*(1/aP(i-1,j) + ...
                1/aPv(j))*(p(i-1,j)-p(i,j)) -  ...
                0.25*dxVec(j)*(1/aP(i-1,j))*(p(i,j)- p(i-2,j)) - ...
                0.25*dxVec(j)*(1/aPv(j))*(p(i,j) -p(i-1,j)));

        else
            v_face(i,j)=0.5*(v(i-1,j) +v(i,j)) + ...
                alpha_uv*(0.5*dxVec(j)*(1/aP(i-1,j) + ...
                1/aP(i,j))*(p(i-1,j)-p(i,j)) -  ...
                0.25*dxVec(j)*(1/aP(i-1,j))*(p(i,j)- p(i-2,j)) - ...
                0.25*dxVec(j)*(1/aP(i,j))*(p(i,j) -p(i-1,j)));
        end
    end
end
